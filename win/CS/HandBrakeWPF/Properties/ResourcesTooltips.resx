<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="FilterView_Deblock" xml:space="preserve">
    <value>The deblocking filter removes a common type of compression artifact.
If your source exhibits 'blockiness', this filter may help clean it up.</value>
  </data>
  <data name="FilterView_DecombDeinterlace" xml:space="preserve">
    <value>Choose decomb or deinterlace filter options.

The decomb filter selectively deinterlaces frames that appear to be interlaced.
This will preserve quality in frames that are not interlaced.

The classic deinterlace filter is applied to all frames.
Frames that are not interlaced will suffer some quality degradation.</value>
  </data>
  <data name="FilterView_Denoise" xml:space="preserve">
    <value>Denoise filtering reduces or removes the appearance of noise and grain.
Film grain and other types of high frequency noise are difficult to compress.
Using this filter on such sources can result in smaller file sizes.</value>
  </data>
  <data name="FilterView_Detelecine" xml:space="preserve">
    <value>This filter removes 'combing' artifacts that are the result of telecining.

Telecining is a process that adjusts film framerates that are 24fps to NTSC video frame rates which are 30fps.</value>
  </data>
  <data name="FilterView_Grayscale" xml:space="preserve">
    <value>If enabled, filter colour components out of video.</value>
  </data>
  <data name="MainView_Destination" xml:space="preserve">
    <value>This is the location and filename where your encoded file will be saved.</value>
  </data>
  <data name="MainView_IpodAtom" xml:space="preserve">
    <value>Add iPod Atom needed by some older iPods.</value>
  </data>
  <data name="MainView_Mux" xml:space="preserve">
    <value>Format to mux encoded tracks to.</value>
  </data>
  <data name="MainView_Optimise" xml:space="preserve">
    <value>Optimise the layout of the MP4 file for progressive download.
This allows a player to initiate playback before downloading the entire file.</value>
  </data>
  <data name="MainView_Range" xml:space="preserve">
    <value>Choose a start and end point of the source title to encode. This can be in chapters, seconds or frames.</value>
  </data>
  <data name="MainView_Title" xml:space="preserve">
    <value>Set the title to encode.
By default, HandBrake will try and select the main title, or the longest if one isn't found.</value>
  </data>
  <data name="PictureSettingsView_Anamorphic" xml:space="preserve">
    <value>None          - Force pixel aspect ratio to 1:1.
Loose         - Use a pixel aspect ratio that is as close as possible to the source video pixel
                      aspect ratio while preserving the original display aspect ratio
Automatic - Use a pixel aspect ratio that maximizes storage resolution while preserving the 
                      original display aspect ratio.</value>
  </data>
  <data name="PictureSettingsView_AutoCrop" xml:space="preserve">
    <value>Automatically crop black borders around edges of the video.</value>
  </data>
  <data name="PictureSettingsView_CropBottom" xml:space="preserve">
    <value>Crop the video from the bottom.</value>
  </data>
  <data name="PictureSettingsView_CropLeft" xml:space="preserve">
    <value>Crop the video from the left side.</value>
  </data>
  <data name="PictureSettingsView_CropRight" xml:space="preserve">
    <value>Crop the video from the right side.</value>
  </data>
  <data name="PictureSettingsView_CropTop" xml:space="preserve">
    <value>Crop the video from the top.</value>
  </data>
  <data name="PictureSettingsView_Height" xml:space="preserve">
    <value>This is the height that the video will be stored at.
The actual display dimensions will differ if the pixel aspect ratio is not 1:1.</value>
  </data>
  <data name="PictureSettingsView_ManualCrop" xml:space="preserve">
    <value>Manually crop the video.</value>
  </data>
  <data name="PictureSettingsView_Modulus" xml:space="preserve">
    <value>Align storage dimensions to multiples of this value.

This setting is only necessary for compatibility with some devices.
You should use 2 unless you experience compatibility issues.</value>
  </data>
  <data name="PictureSettingsView_PAR" xml:space="preserve">
    <value>Pixel aspect defines the shape of the pixels.
A 1:1 ratio defines a square pixel.  Other values define rectangular shapes.
Players will scale the image in order to achieve the specified aspect.</value>
  </data>
  <data name="PictureSettingsView_Width" xml:space="preserve">
    <value>This is the width that the video will be stored at.
The actual display dimensions will differ if the pixel aspect ratio is not 1:1.</value>
  </data>
  <data name="QueueView_DeleteJob" xml:space="preserve">
    <value>Delete the job from the queue.</value>
  </data>
  <data name="QueueView_ResetJobStatus" xml:space="preserve">
    <value>Reset job status to Waiting.</value>
  </data>
  <data name="QueueView_SendJobBack" xml:space="preserve">
    <value>Send the job back to the main window for editing.</value>
  </data>
  <data name="Video_AdvancedOptions" xml:space="preserve">
    <value>Use advanced options Tab for x264 settings.</value>
  </data>
  <data name="Video_AvgBitrate" xml:space="preserve">
    <value>Set the average bitrate.

The instantaneous bitrate can be much higher or lower at any point in time.
But the average over a long duration will be the value set here.  If you need
to limit instantaneous bitrate, look into x264's vbv-bufsize and vbv-maxrate settings.</value>
  </data>
  <data name="Video_ConstantFramerate" xml:space="preserve">
    <value>Enables constant framerate output.</value>
  </data>
  <data name="Video_Encoders" xml:space="preserve">
    <value>Available video encoders.</value>
  </data>
  <data name="Video_EncoderTune" xml:space="preserve">
    <value>Tune settings to optimize for common scenarios.

This can improve effeciency for particular source characteristics or set
characteristics of the output file.  Changes will be applied after the
preset but before all other parameters.</value>
  </data>
  <data name="Video_ExtraOpts" xml:space="preserve">
    <value>Additional encoder settings.

Colon separated list of encoder options.</value>
  </data>
  <data name="Video_FastDecode" xml:space="preserve">
    <value>Reduce decoder CPU usage.

Set this if your device is struggling to play the output (dropped frames).</value>
  </data>
  <data name="Video_Framerate" xml:space="preserve">
    <value>Output framerate.

'Same as source' is recommended. If your source video has a variable framerate, 'Same as source' will preserve it.</value>
  </data>
  <data name="Video_Level" xml:space="preserve">
    <value>Sets and ensures compliance with the specified level.

Overrides all other settings.</value>
  </data>
  <data name="Video_PeakFramerate" xml:space="preserve">
    <value>Enables variable framerate output with a peak rate determined by the framerate setting.</value>
  </data>
  <data name="Video_Presets" xml:space="preserve">
    <value>Adjusts encoder settings to trade off compression efficiency against encoding speed.

This establishes your default encoder settings.
Tunes, profiles, levels and advanced option string will be applied to this.
You should generally set this option to the slowest you can bear since slower
settings will result in better quality or smaller files.</value>
  </data>
  <data name="Video_Profile" xml:space="preserve">
    <value>Sets and ensures compliance with the specified profile.

Overrides all other settings.</value>
  </data>
  <data name="Video_Quality" xml:space="preserve">
    <value>Set the desired quality factor.
The encoder targets a certain quality.
The scale used by each video encoder is different.

x264's scale is logarithmic and lower values correspond to higher quality.
So small decreases in value will result in progressively larger increases
in the resulting file size.  A value of 0 means lossless and will result
in a file size that is larger than the original source, unless the source
was also lossless.
Suggested values are: 18 to 20 for standard definition sources and 20 to 23 for high definition sources.

FFMpeg's and Theora's scale is more linear.
These encoders do not have a lossless mode.</value>
  </data>
  <data name="Video_TurboFirstPass" xml:space="preserve">
    <value>During the 1st pass of a 2 pass encode, use settings that speed things along.</value>
  </data>
  <data name="Video_TwoPass" xml:space="preserve">
    <value>Perform 2 Pass Encoding.

The 'Bitrate' option is prerequisite. During the 1st pass, statistics about
the video are collected.  Then in the second pass, those statistics are used
to make bitrate allocation decisions.</value>
  </data>
  <data name="Video_VariableFramerate" xml:space="preserve">
    <value>Enables variable framerate output.

VFR is not compatible with some players.</value>
  </data>
  <data name="MainView_WhenDone" xml:space="preserve">
    <value>When HandBrake has finished the current queue or encode it will perform this action.</value>
  </data>
</root>