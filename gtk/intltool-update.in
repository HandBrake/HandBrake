#!@INTLTOOL_PERL@ -w
# -*- Mode: perl; indent-tabs-mode: nil; c-basic-offset: 4  -*-

#
#  The Intltool Message Updater
#
#  Copyright (C) 2000-2003 Free Software Foundation.
#
#  Intltool is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License 
#  version 2 published by the Free Software Foundation.
#
#  Intltool is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
#  As a special exception to the GNU General Public License, if you
#  distribute this file as part of a program that contains a
#  configuration script generated by Autoconf, you may include it under
#  the same distribution terms that you use for the rest of that program.
#
#  Authors: Kenneth Christiansen <kenneth@gnu.org>
#           Maciej Stachowiak
#           Darin Adler <darin@bentspoon.com>

## Release information
my $PROGRAM = "intltool-update";
my $VERSION = "0.37.1";
my $PACKAGE = "intltool";

## Loaded modules
use strict;
use Getopt::Long;
use Cwd;
use File::Copy;
use File::Find;

## Scalars used by the option stuff
my $HELP_ARG 	   = 0;
my $VERSION_ARG    = 0;
my $DIST_ARG	   = 0;
my $POT_ARG	   = 0;
my $HEADERS_ARG    = 0;
my $MAINTAIN_ARG   = 0;
my $REPORT_ARG     = 0;
my $VERBOSE	   = 0;
my $GETTEXT_PACKAGE = "";
my $OUTPUT_FILE    = "";

my @languages;
my %varhash = ();
my %po_files_by_lang = ();

# Regular expressions to categorize file types.
# FIXME: Please check if the following is correct

my $xml_support =
"xml(?:\\.in)*|".	# http://www.w3.org/XML/ (Note: .in is not required)
"ui|".			# Bonobo specific - User Interface desc. files
"lang|".		# ?
"glade2?(?:\\.in)*|".	# Glade specific - User Interface desc. files (Note: .in is not required)
"scm(?:\\.in)*|".	# ? (Note: .in is not required)
"oaf(?:\\.in)+|".	# DEPRECATED: Replaces by Bonobo .server files 
"etspec|".		# ?
"server(?:\\.in)+|".	# Bonobo specific
"sheet(?:\\.in)+|".	# ?
"schemas(?:\\.in)+|".	# GConf specific
"pong(?:\\.in)+|".	# DEPRECATED: PONG is not used [by GNOME] any longer.
"kbd(?:\\.in)+|".	# GOK specific. 
"policy(?:\\.in)+";	# PolicyKit files

my $ini_support =
"icon(?:\\.in)+|".	# http://www.freedesktop.org/Standards/icon-theme-spec
"desktop(?:\\.in)+|".	# http://www.freedesktop.org/Standards/menu-spec
"caves(?:\\.in)+|".	# GNOME Games specific
"directory(?:\\.in)+|".	# http://www.freedesktop.org/Standards/menu-spec
"soundlist(?:\\.in)+|".	# GNOME specific
"keys(?:\\.in)+|".	# GNOME Mime database specific
"theme(?:\\.in)+|".	# http://www.freedesktop.org/Standards/icon-theme-spec
"service(?:\\.in)+";    # DBus specific

my $buildin_gettext_support = 
"c|y|cs|cc|cpp|c\\+\\+|h|hh|gob|py";

## Always flush buffer when printing
$| = 1;

## Sometimes the source tree will be rooted somewhere else.
my $SRCDIR = $ENV{"srcdir"} || ".";
my $POTFILES_in;

$POTFILES_in = "<$SRCDIR/POTFILES.in";

my $devnull = ($^O eq 'MSWin32' ? 'NUL:' : '/dev/null');

## Handle options
GetOptions 
(
 "help" 	       => \$HELP_ARG,
 "version" 	       => \$VERSION_ARG,
 "dist|d"	       => \$DIST_ARG,
 "pot|p"	       => \$POT_ARG,
 "headers|s"	       => \$HEADERS_ARG,
 "maintain|m"	       => \$MAINTAIN_ARG,
 "report|r"	       => \$REPORT_ARG,
 "verbose|x"	       => \$VERBOSE,
 "gettext-package|g=s" => \$GETTEXT_PACKAGE,
 "output-file|o=s"     => \$OUTPUT_FILE,
 ) or &Console_WriteError_InvalidOption;

&Console_Write_IntltoolHelp if $HELP_ARG;
&Console_Write_IntltoolVersion if $VERSION_ARG;

my $arg_count = ($DIST_ARG > 0)
    + ($POT_ARG > 0)
    + ($HEADERS_ARG > 0)
    + ($MAINTAIN_ARG > 0)
    + ($REPORT_ARG > 0);

&Console_Write_IntltoolHelp if $arg_count > 1;

my $PKGNAME = FindPackageName ();

# --version and --help don't require a module name
my $MODULE = $GETTEXT_PACKAGE || $PKGNAME || "unknown";

if ($POT_ARG)
{
    &GenerateHeaders;
    &GeneratePOTemplate;
}
elsif ($HEADERS_ARG)
{
    &GenerateHeaders;
}
elsif ($MAINTAIN_ARG)
{
    &FindLeftoutFiles;
}
elsif ($REPORT_ARG)
{
    &GenerateHeaders;
    &GeneratePOTemplate;
    &Console_Write_CoverageReport;
}
elsif ((defined $ARGV[0]) && $ARGV[0] =~ /^[a-z]/)
{
    my $lang = $ARGV[0];

    ## Report error if the language file supplied
    ## to the command line is non-existent
    &Console_WriteError_NotExisting("$SRCDIR/$lang.po")
        if ! -s "$SRCDIR/$lang.po";

    if (!$DIST_ARG)
    {
	print "Working, please wait..." if $VERBOSE;
	&GenerateHeaders;
	&GeneratePOTemplate;
    }
    &POFile_Update ($lang, $OUTPUT_FILE);
    &Console_Write_TranslationStatus ($lang, $OUTPUT_FILE);
} 
else 
{
    &Console_Write_IntltoolHelp;
}

exit;

#########

sub Console_Write_IntltoolVersion
{
    print <<_EOF_;
${PROGRAM} (${PACKAGE}) $VERSION
Written by Kenneth Christiansen, Maciej Stachowiak, and Darin Adler.

Copyright (C) 2000-2003 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
_EOF_
    exit;
}

sub Console_Write_IntltoolHelp
{
    print <<_EOF_;
Usage: ${PROGRAM} [OPTION]... LANGCODE
Updates PO template files and merge them with the translations.

Mode of operation (only one is allowed):
  -p, --pot                   generate the PO template only
  -s, --headers               generate the header files in POTFILES.in
  -m, --maintain              search for left out files from POTFILES.in
  -r, --report                display a status report for the module
  -d, --dist                  merge LANGCODE.po with existing PO template

Extra options:
  -g, --gettext-package=NAME  override PO template name, useful with --pot
  -o, --output-file=FILE      write merged translation to FILE
  -x, --verbose               display lots of feedback
      --help                  display this help and exit
      --version               output version information and exit

Examples of use:
${PROGRAM} --pot    just create a new PO template
${PROGRAM} xy       create new PO template and merge xy.po with it

Report bugs to http://bugzilla.gnome.org/ (product name "$PACKAGE")
or send email to <xml-i18n-tools\@gnome.org>.
_EOF_
    exit;
}

sub echo_n
{
    my $str = shift;
    my $ret = `echo "$str"`;

    $ret =~ s/\n$//; # do we need the "s" flag?

    return $ret;
}

sub POFile_DetermineType ($) 
{
   my $type = $_;
   my $gettext_type;

   my $xml_regex     = "(?:" . $xml_support . ")";
   my $ini_regex     = "(?:" . $ini_support . ")";
   my $buildin_regex = "(?:" . $buildin_gettext_support . ")";

   if ($type =~ /\[type: gettext\/([^\]].*)]/) 
   {
	$gettext_type=$1;
   }
   elsif ($type =~ /schemas(\.in)+$/) 
   {
	$gettext_type="schemas";
   }
   elsif ($type =~ /glade2?(\.in)*$/) 
   {
       $gettext_type="glade";
   }
   elsif ($type =~ /scm(\.in)*$/) 
   {
       $gettext_type="scheme";
   }
   elsif ($type =~ /keys(\.in)+$/) 
   {
       $gettext_type="keys";
   }

   # bucket types

   elsif ($type =~ /$xml_regex$/) 
   {
       $gettext_type="xml";
   }
   elsif ($type =~ /$ini_regex$/) 
   { 
       $gettext_type="ini";
   }
   elsif ($type =~ /$buildin_regex$/) 
   {
       $gettext_type="buildin";
   }
   else
   { 
       $gettext_type="unknown"; 
   }

   return "gettext\/$gettext_type";
}

sub TextFile_DetermineEncoding ($) 
{
    my $gettext_code="ASCII"; # All files are ASCII by default
    my $filetype=`file $_ | cut -d ' ' -f 2`;

    if ($? eq "0")
    {
	if ($filetype =~ /^(ISO|UTF)/)
	{
	    chomp ($gettext_code = $filetype);
	}
	elsif ($filetype =~ /^XML/)
	{
	    $gettext_code="UTF-8"; # We asume that .glade and other .xml files are UTF-8
	}
    }

    return $gettext_code;
}

sub isNotValidMissing
{
    my ($file) = @_;

    return if $file =~ /^\{arch\}\/.*$/;
    return if $file =~ /^$varhash{"PACKAGE"}-$varhash{"VERSION"}\/.*$/;
}

sub FindLeftoutFiles
{
    my (@buf_i18n_plain,
	@buf_i18n_xml,
	@buf_i18n_xml_unmarked,
	@buf_i18n_ini,
	@buf_potfiles,
	@buf_potfiles_ignore,
	@buf_allfiles,
	@buf_allfiles_sorted,
	@buf_potfiles_sorted,
        @buf_potfiles_ignore_sorted
    );

    ## Search and find all translatable files
    find sub { 
	push @buf_i18n_plain,        "$File::Find::name" if /\.($buildin_gettext_support)$/;
	push @buf_i18n_xml,          "$File::Find::name" if /\.($xml_support)$/;
	push @buf_i18n_ini,          "$File::Find::name" if /\.($ini_support)$/;
	push @buf_i18n_xml_unmarked, "$File::Find::name" if /\.(schemas(\.in)+)$/;
	}, "..";
    find sub { 
	push @buf_i18n_plain,        "$File::Find::name" if /\.($buildin_gettext_support)$/;
	push @buf_i18n_xml,          "$File::Find::name" if /\.($xml_support)$/;
	push @buf_i18n_ini,          "$File::Find::name" if /\.($ini_support)$/;
	push @buf_i18n_xml_unmarked, "$File::Find::name" if /\.(schemas(\.in)+)$/;
	}, "$SRCDIR/.." if "$SRCDIR" ne ".";

    open POTFILES, $POTFILES_in or die "$PROGRAM:  there's no POTFILES.in!\n";
    @buf_potfiles = grep !/^(#|\s*$)/, <POTFILES>;
    close POTFILES;

    foreach (@buf_potfiles) {
	s/^\[.*]\s*//;
    }

    print "Searching for missing translatable files...\n" if $VERBOSE;

    ## Check if we should ignore some found files, when
    ## comparing with POTFILES.in
    foreach my $ignore ("POTFILES.skip", "POTFILES.ignore")
    {
	(-s "$SRCDIR/$ignore") or next;

	if ("$ignore" eq "POTFILES.ignore")
	{
	    print "The usage of POTFILES.ignore is deprecated. Please consider moving the\n".
		  "content of this file to POTFILES.skip.\n";
	}

	print "Found $ignore: Ignoring files...\n" if $VERBOSE;
	open FILE, "<$SRCDIR/$ignore" or die "ERROR: Failed to open $SRCDIR/$ignore!\n";
	    
	while (<FILE>)
	{
	    push @buf_potfiles_ignore, $_ unless /^(#|\s*$)/;
	}
	close FILE;

	@buf_potfiles_ignore_sorted = sort (@buf_potfiles_ignore);
    }

    foreach my $file (@buf_i18n_plain)
    {
	my $in_comment = 0;
	my $in_macro = 0;

	open FILE, "<$file";
	while (<FILE>)
	{
	    # Handle continued multi-line comment.
	    if ($in_comment)
	    {
		next unless s-.*\*/--;
		$in_comment = 0;
	    }

	    # Handle continued macro.
	    if ($in_macro)
	    {
		$in_macro = 0 unless /\\$/;
		next;
	    }

	    # Handle start of macro (or any preprocessor directive).
	    if (/^\s*\#/)
	    {
		$in_macro = 1 if /^([^\\]|\\.)*\\$/;
		next;
	    }

	    # Handle comments and quoted text.
	    while (m-(/\*|//|\'|\")-) # \' and \" keep emacs perl mode happy
	    {
		my $match = $1;
		if ($match eq "/*")
		{
		    if (!s-/\*.*?\*/--)
		    {
			s-/\*.*--;
			$in_comment = 1;
		    }
		}
		elsif ($match eq "//")
		{
		    s-//.*--;
		}
		else # ' or "
		{
		    if (!s-$match([^\\]|\\.)*?$match-QUOTEDTEXT-)
		    {
			warn "mismatched quotes at line $. in $file\n";
			s-$match.*--;
		    }
		}
	    }	    

	    if (/\w\.GetString *\(QUOTEDTEXT/)
	    {
                if (defined isNotValidMissing (unpack("x3 A*", $file))) {
                    ## Remove the first 3 chars and add newline
                    push @buf_allfiles, unpack("x3 A*", $file) . "\n";
                }
		last;
	    }

            ## C_ N_ Q_ and _ are the macros defined in gi8n.h
	    if (/[CNQ]?_ *\(QUOTEDTEXT/)
	    {
                if (defined isNotValidMissing (unpack("x3 A*", $file))) {
                    ## Remove the first 3 chars and add newline
                    push @buf_allfiles, unpack("x3 A*", $file) . "\n";
                }
		last;
	    }
	}
	close FILE;
    }

    foreach my $file (@buf_i18n_xml) 
    {
	open FILE, "<$file";
	
	while (<FILE>) 
	{
	    # FIXME: share the pattern matching code with intltool-extract
	    if (/\s_[-A-Za-z0-9._:]+\s*=\s*\"([^"]+)\"/ || /<_[^>]+>/ || /translatable=\"yes\"/)
	    {
                if (defined isNotValidMissing (unpack("x3 A*", $file))) {
                    push @buf_allfiles, unpack("x3 A*", $file) . "\n";
                }
		last;
	    }
	}
	close FILE;
    }

    foreach my $file (@buf_i18n_ini)
    {
	open FILE, "<$file";
	while (<FILE>) 
	{
	    if (/_(.*)=/)
	    {
                if (defined isNotValidMissing (unpack("x3 A*", $file))) {
                    push @buf_allfiles, unpack("x3 A*", $file) . "\n";
                }
		last;
	    }
	}
	close FILE;
    }

    foreach my $file (@buf_i18n_xml_unmarked)
    {
        if (defined isNotValidMissing (unpack("x3 A*", $file))) {
            push @buf_allfiles, unpack("x3 A*", $file) . "\n";
        }
    }


    @buf_allfiles_sorted = sort (@buf_allfiles);
    @buf_potfiles_sorted = sort (@buf_potfiles);

    my %in2;
    foreach (@buf_potfiles_sorted) 
    {
        s#^$SRCDIR/../##;
        s#^$SRCDIR/##;
	$in2{$_} = 1;
    }

    foreach (@buf_potfiles_ignore_sorted) 
    {
        s#^$SRCDIR/../##;
        s#^$SRCDIR/##;
	$in2{$_} = 1;
    }

    my @result;

    foreach (@buf_allfiles_sorted)
    {
        my $dummy = $_;
        my $srcdir = $SRCDIR;

        $srcdir =~ s#^../##;
        $dummy =~ s#^$srcdir/../##;
        $dummy =~ s#^$srcdir/##;
        $dummy =~ s#_build/##;
	if (!exists($in2{$dummy}))
	{
	    push @result, $dummy
	}
    }

    my @buf_potfiles_notexist;

    foreach (@buf_potfiles_sorted)
    {
	chomp (my $dummy = $_);
	if ("$dummy" ne "" and !(-f "$SRCDIR/../$dummy" or -f "../$dummy"))
	{
	    push @buf_potfiles_notexist, $_;
	}
    }

    ## Save file with information about the files missing
    ## if any, and give information about this procedure.
    if (@result + @buf_potfiles_notexist > 0)
    {
	if (@result) 
	{
	    print "\n" if $VERBOSE;
	    unlink "missing";
	    open OUT, ">missing";
	    print OUT @result;
	    close OUT;
	    warn "\e[1mThe following files contain translations and are currently not in use. Please\e[0m\n".
	         "\e[1mconsider adding these to the POTFILES.in file, located in the po/ directory.\e[0m\n\n";
	    print STDERR @result, "\n";
	    warn "If some of these files are left out on purpose then please add them to\n".
		 "POTFILES.skip instead of POTFILES.in. A file \e[1m'missing'\e[0m containing this list\n".
		 "of left out files has been written in the current directory.\n";
	}
	if (@buf_potfiles_notexist)
	{
	    unlink "notexist";
	    open OUT, ">notexist";
	    print OUT @buf_potfiles_notexist;
	    close OUT;
	    warn "\n" if ($VERBOSE or @result);
	    warn "\e[1mThe following files do not exist anymore:\e[0m\n\n";
	    warn @buf_potfiles_notexist, "\n";
	    warn "Please remove them from POTFILES.in. A file \e[1m'notexist'\e[0m\n".
		 "containing this list of absent files has been written in the current directory.\n";
	}
    }

    ## If there is nothing to complain about, notify the user
    else {
	print "\nAll files containing translations are present in POTFILES.in.\n" if $VERBOSE;
    }
}

sub Console_WriteError_InvalidOption
{
    ## Handle invalid arguments
    print STDERR "Try `${PROGRAM} --help' for more information.\n";
    exit 1;
}

sub isProgramInPath
{
    my ($file) = @_;
    # If either a file exists, or when run it returns 0 exit status
    return 1 if ((-x $file) or (system("$file --version >$devnull") == 0));
    return 0;
}

sub isGNUGettextTool
{
    my ($file) = @_;
    # Check that we are using GNU gettext tools
    if (isProgramInPath ($file))
    {
        my $version = `$file --version`;
        return 1 if ($version =~ m/.*\(GNU .*\).*/);
    }
    return 0;
}

sub GenerateHeaders
{
    my $EXTRACT = $ENV{"INTLTOOL_EXTRACT"} || "intltool-extract";

    ## Generate the .h header files, so we can allow glade and
    ## xml translation support
    if (! isProgramInPath ("$EXTRACT"))
    {
	print STDERR "\n *** The intltool-extract script wasn't found!"
	     ."\n *** Without it, intltool-update can not generate files.\n";
	exit;
    }
    else
    {
	open (FILE, $POTFILES_in) or die "$PROGRAM: POTFILES.in not found.\n";
	
	while (<FILE>) 
	{
	   chomp;
	   next if /^\[\s*encoding/;

	   ## Find xml files in POTFILES.in and generate the
	   ## files with help from the extract script

	   my $gettext_type= &POFile_DetermineType ($1);

	   if (/\.($xml_support|$ini_support)$/ || /^\[/)
	   {
	       s/^\[[^\[].*]\s*//;

	       my $filename = "../$_";

	       if ($VERBOSE)
	       {
		   system ($EXTRACT, "--update", "--srcdir=$SRCDIR",
			   "--type=$gettext_type", $filename);
	       } 
	       else 
	       {
	 	   system ($EXTRACT, "--update", "--type=$gettext_type", 
			   "--srcdir=$SRCDIR", "--quiet", $filename);
	       }
	   }
       }
       close FILE;
   }
}

#
# Generate .pot file from POTFILES.in
#
sub GeneratePOTemplate
{
    my $XGETTEXT = $ENV{"XGETTEXT"} || "xgettext";
    my $XGETTEXT_ARGS = $ENV{"XGETTEXT_ARGS"} || '';
    chomp $XGETTEXT;

    if (! isGNUGettextTool ("$XGETTEXT"))
    {
	print STDERR " *** GNU xgettext is not found on this system!\n".
		     " *** Without it, intltool-update can not extract strings.\n";
	exit;
    }

    print "Building $MODULE.pot...\n" if $VERBOSE;

    open INFILE, $POTFILES_in;
    unlink "POTFILES.in.temp";
    open OUTFILE, ">POTFILES.in.temp" or die("Cannot open POTFILES.in.temp for writing");

    my $gettext_support_nonascii = 0;

    # checks for GNU gettext >= 0.12
    my $dummy = `$XGETTEXT --version --from-code=UTF-8 >$devnull 2>$devnull`;
    if ($? == 0)
    {
	$gettext_support_nonascii = 1;
    }
    else
    {
	# urge everybody to upgrade gettext
	print STDERR "WARNING: This version of gettext does not support extracting non-ASCII\n".
		     "         strings. That means you should install a version of gettext\n".
		     "         that supports non-ASCII strings (such as GNU gettext >= 0.12),\n".
		     "         or have to let non-ASCII strings untranslated. (If there is any)\n";
    }

    my $encoding = "ASCII";
    my $forced_gettext_code;
    my @temp_headers;
    my $encoding_problem_is_reported = 0;

    while (<INFILE>) 
    {
	next if (/^#/ or /^\s*$/);

	chomp;

	my $gettext_code;

	if (/^\[\s*encoding:\s*(.*)\s*\]/)
	{
	    $forced_gettext_code=$1;
	}
	elsif (/\.($xml_support|$ini_support)$/ || /^\[/)
	{
	    s/^\[.*]\s*//;
            print OUTFILE "../$_.h\n";
	    push @temp_headers, "../$_.h";
	    $gettext_code = &TextFile_DetermineEncoding ("../$_.h") if ($gettext_support_nonascii and not defined $forced_gettext_code);
	} 
	else 
	{
            print OUTFILE "$SRCDIR/../$_\n";
	    $gettext_code = &TextFile_DetermineEncoding ("$SRCDIR/../$_") if ($gettext_support_nonascii and not defined $forced_gettext_code);
	}

	next if (! $gettext_support_nonascii);

	if (defined $forced_gettext_code)
	{
	    $encoding=$forced_gettext_code;
	}
	elsif (defined $gettext_code and "$encoding" ne "$gettext_code")
	{
	    if ($encoding eq "ASCII")
	    {
		$encoding=$gettext_code;
	    }
	    elsif ($gettext_code ne "ASCII")
	    {
		# Only report once because the message is quite long
		if (! $encoding_problem_is_reported)
		{
		    print STDERR "WARNING: You should use the same file encoding for all your project files,\n".
				 "         but $PROGRAM thinks that most of the source files are in\n".
				 "         $encoding encoding, while \"$_\" is (likely) in\n".
		       		 "         $gettext_code encoding. If you are sure that all translatable strings\n".
				 "         are in same encoding (say UTF-8), please \e[1m*prepend*\e[0m the following\n".
				 "         line to POTFILES.in:\n\n".
				 "                 [encoding: UTF-8]\n\n".
				 "         and make sure that configure.in/ac checks for $PACKAGE >= 0.27 .\n".
				 "(such warning message will only be reported once.)\n";
		    $encoding_problem_is_reported = 1;
		}
	    }
	}
    }

    close OUTFILE;
    close INFILE;

    unlink "$MODULE.pot";
    my @xgettext_argument=("$XGETTEXT",
			   "--add-comments",
			   "--directory\=.",
                           "--default-domain\=$MODULE",
                           "--flag\=g_strdup_printf:1:c-format",
                           "--flag\=g_string_printf:2:c-format",
                           "--flag\=g_string_append_printf:2:c-format",
                           "--flag\=g_error_new:3:c-format",
                           "--flag\=g_set_error:4:c-format",
                           "--flag\=g_markup_printf_escaped:1:c-format",
                           "--flag\=g_log:3:c-format",
                           "--flag\=g_print:1:c-format",
                           "--flag\=g_printerr:1:c-format",
                           "--flag\=g_printf:1:c-format",
                           "--flag\=g_fprintf:2:c-format",
                           "--flag\=g_sprintf:2:c-format",
                           "--flag\=g_snprintf:3:c-format",
                           "--flag\=g_scanner_error:2:c-format",
                           "--flag\=g_scanner_warn:2:c-format",
			   "--output\=$MODULE\.pot",
			   "--files-from\=\.\/POTFILES\.in\.temp");
    my $XGETTEXT_KEYWORDS = &FindPOTKeywords;
    push @xgettext_argument, $XGETTEXT_KEYWORDS;
    my $MSGID_BUGS_ADDRESS = &FindMakevarsBugAddress;
    push @xgettext_argument, "--msgid-bugs-address\=\"$MSGID_BUGS_ADDRESS\"" if $MSGID_BUGS_ADDRESS;
    push @xgettext_argument, "--from-code\=$encoding" if ($gettext_support_nonascii);
    push @xgettext_argument, $XGETTEXT_ARGS if $XGETTEXT_ARGS;
    my $xgettext_command = join ' ', @xgettext_argument;

    # intercept xgettext error message
    print "Running $xgettext_command\n" if $VERBOSE;
    my $xgettext_error_msg = `$xgettext_command 2>\&1`;
    my $command_failed = $?;

    unlink "POTFILES.in.temp";

    print "Removing generated header (.h) files..." if $VERBOSE;
    unlink foreach (@temp_headers);
    print "done.\n" if $VERBOSE;

    if (! $command_failed)
    {
	if (! -e "$MODULE.pot")
	{
	    print "None of the files in POTFILES.in contain strings marked for translation.\n" if $VERBOSE;
	}
	else
	{
	    print "Wrote $MODULE.pot\n" if $VERBOSE;
	}
    }
    else
    {
	if ($xgettext_error_msg =~ /--from-code/)
	{
	    # replace non-ASCII error message with a more useful one.
	    print STDERR "ERROR: xgettext failed to generate PO template file because there is non-ASCII\n".
			 "       string marked for translation. Please make sure that all strings marked\n".
			 "       for translation are in uniform encoding (say UTF-8), then \e[1m*prepend*\e[0m the\n".
			 "       following line to POTFILES.in and rerun $PROGRAM:\n\n".
			 "           [encoding: UTF-8]\n\n";
	}
	else
	{
	    print STDERR "$xgettext_error_msg";
	    if (-e "$MODULE.pot")
	    {
		# is this possible?
		print STDERR "ERROR: xgettext failed but still managed to generate PO template file.\n".
			     "       Please consult error message above if there is any.\n";
	    }
	    else
	    {
		print STDERR "ERROR: xgettext failed to generate PO template file. Please consult\n".
			     "       error message above if there is any.\n";
	    }
	}
	exit (1);
    }
}

sub POFile_Update
{
    -f "$MODULE.pot" or die "$PROGRAM: $MODULE.pot does not exist.\n";

    my $MSGMERGE = $ENV{"MSGMERGE"} || "msgmerge";
    my ($lang, $outfile) = @_;

    if (! isGNUGettextTool ("$MSGMERGE"))
    {
	print STDERR " *** GNU msgmerge is not found on this system!\n".
		     " *** Without it, intltool-update can not extract strings.\n";
	exit;
    }

    print "Merging $SRCDIR/$lang.po with $MODULE.pot..." if $VERBOSE;

    my $infile = "$SRCDIR/$lang.po";
    $outfile = "$SRCDIR/$lang.po" if ($outfile eq "");

    # I think msgmerge won't overwrite old file if merge is not successful
    system ("$MSGMERGE", "-o", $outfile, $infile, "$MODULE.pot");
}

sub Console_WriteError_NotExisting
{
    my ($file) = @_;

    ## Report error if supplied language file is non-existing
    print STDERR "$PROGRAM: $file does not exist!\n";
    print STDERR "Try '$PROGRAM --help' for more information.\n";
    exit;
}

sub GatherPOFiles
{
    my @po_files = glob ("./*.po");

    @languages = map (&POFile_GetLanguage, @po_files);

    foreach my $lang (@languages) 
    {
	$po_files_by_lang{$lang} = shift (@po_files);
    }
}

sub POFile_GetLanguage ($)
{
    s/^(.*\/)?(.+)\.po$/$2/;
    return $_;
}

sub Console_Write_TranslationStatus
{
    my ($lang, $output_file) = @_;
    my $MSGFMT = $ENV{"MSGFMT"} || "msgfmt";

    if (! isGNUGettextTool ("$MSGFMT"))
    {
	print STDERR " *** GNU msgfmt is not found on this system!\n".
		     " *** Without it, intltool-update can not extract strings.\n";
	exit;
    }

    $output_file = "$SRCDIR/$lang.po" if ($output_file eq "");

    system ("$MSGFMT", "-o", "$devnull", "--verbose", $output_file);
}

sub Console_Write_CoverageReport
{
    my $MSGFMT = $ENV{"MSGFMT"} || "msgfmt";

    if (! isGNUGettextTool ("$MSGFMT"))
    {
	print STDERR " *** GNU msgfmt is not found on this system!\n".
		     " *** Without it, intltool-update can not extract strings.\n";
	exit;
    }

    &GatherPOFiles;

    foreach my $lang (@languages) 
    {
	print STDERR "$lang: ";
	&POFile_Update ($lang, "");
    }

    print STDERR "\n\n * Current translation support in $MODULE \n\n";

    foreach my $lang (@languages)
    {
	print STDERR "$lang: ";
	system ("$MSGFMT", "-o", "$devnull", "--verbose", "$SRCDIR/$lang.po");
    }
}

sub SubstituteVariable
{
    my ($str) = @_;
    
    # always need to rewind file whenever it has been accessed
    seek (CONF, 0, 0);

    # cache each variable. varhash is global to we can add
    # variables elsewhere.
    while (<CONF>)
    {
	if (/^(\w+)=(.*)$/)
	{
	    ($varhash{$1} = $2) =~  s/^["'](.*)["']$/$1/;
	}
    }
    
    if ($str =~ /^(.*)\${?([A-Z_]+)}?(.*)$/)
    {
	my $rest = $3;
	my $untouched = $1;
	my $sub = "";
        # Ignore recursive definitions of variables
        $sub = $varhash{$2} if defined $varhash{$2} and $varhash{$2} !~ /\${?$2}?/;

	return SubstituteVariable ("$untouched$sub$rest");
    }
    
    # We're using Perl backticks ` and "echo -n" here in order to 
    # expand any shell escapes (such as backticks themselves) in every variable
    return echo_n ($str);
}

sub CONF_Handle_Open
{
    my $base_dirname = getcwd();
    $base_dirname =~ s@.*/@@;

    my ($conf_in, $src_dir);

    if ($base_dirname =~ /^po(-.+)?$/) 
    {
	if (-f "Makevars") 
	{
	    my $makefile_source;

	    local (*IN);
	    open (IN, "<Makevars") || die "can't open Makevars: $!";

	    while (<IN>) 
	    {
		if (/^top_builddir[ \t]*=/) 
		{
		    $src_dir = $_;
		    $src_dir =~ s/^top_builddir[ \t]*=[ \t]*([^ \t\n\r]*)/$1/;

		    chomp $src_dir;
                    if (-f "$src_dir" . "/configure.ac") {
                        $conf_in = "$src_dir" . "/configure.ac" . "\n";
                    } else {
                        $conf_in = "$src_dir" . "/configure.in" . "\n";
                    }
		    last;
		}
	    }
	    close IN;

	    $conf_in || die "Cannot find top_builddir in Makevars.";
	}
	elsif (-f "$SRCDIR/../configure.ac") 
	{
	    $conf_in = "$SRCDIR/../configure.ac";
	} 
	elsif (-f "$SRCDIR/../configure.in") 
	{
	    $conf_in = "$SRCDIR/../configure.in";
	} 
	else 
	{
	    my $makefile_source;

	    local (*IN);
	    open (IN, "<Makefile") || return;

	    while (<IN>) 
	    {
		if (/^top_srcdir[ \t]*=/) 
		{
		    $src_dir = $_;		    
		    $src_dir =~ s/^top_srcdir[ \t]*=[ \t]*([^ \t\n\r]*)/$1/;

		    chomp $src_dir;
		    $conf_in = "$src_dir" . "/configure.in" . "\n";

		    last;
		}
	    }
	    close IN;

	    $conf_in || die "Cannot find top_srcdir in Makefile.";
	}

	open (CONF, "<$conf_in");
    }
    else
    {
	print STDERR "$PROGRAM: Unable to proceed.\n" .
		     "Make sure to run this script inside the po directory.\n";
	exit;
    }
}

sub FindPackageName
{
    my $version;
    my $domain = &FindMakevarsDomain;
    my $name = $domain || "untitled";

    &CONF_Handle_Open;

    my $conf_source; {
	local (*IN);
	open (IN, "<&CONF") || return $name;
	seek (IN, 0, 0);
	local $/; # slurp mode
	$conf_source = <IN>;
	close IN;
    }

    # priority for getting package name:
    # 1. GETTEXT_PACKAGE
    # 2. first argument of AC_INIT (with >= 2 arguments)
    # 3. first argument of AM_INIT_AUTOMAKE (with >= 2 argument)

    # /^AM_INIT_AUTOMAKE\([\s\[]*([^,\)\s\]]+)/m 
    # the \s makes this not work, why?
    if ($conf_source =~ /^AM_INIT_AUTOMAKE\(([^,\)]+),([^,\)]+)/m)
    {
	($name, $version) = ($1, $2);
	$name    =~ s/[\[\]\s]//g;
	$version =~ s/[\[\]\s]//g;
	$varhash{"PACKAGE_NAME"} = $name if (not $name =~ /\${?AC_PACKAGE_NAME}?/);
	$varhash{"PACKAGE"} = $name if (not $name =~ /\${?PACKAGE}?/);
	$varhash{"PACKAGE_VERSION"} = $version if (not $name =~ /\${?AC_PACKAGE_VERSION}?/);
	$varhash{"VERSION"} = $version if (not $name =~ /\${?VERSION}?/);
    }
    
    if ($conf_source =~ /^AC_INIT\(([^,\)]+),([^,\)]+)/m) 
    {
	($name, $version) = ($1, $2);
	$name    =~ s/[\[\]\s]//g;
	$version =~ s/[\[\]\s]//g;
	$varhash{"PACKAGE_NAME"} = $name if (not $name =~ /\${?AC_PACKAGE_NAME}?/);
	$varhash{"PACKAGE"} = $name if (not $name =~ /\${?PACKAGE}?/);
	$varhash{"PACKAGE_VERSION"} = $version if (not $name =~ /\${?AC_PACKAGE_VERSION}?/);
	$varhash{"VERSION"} = $version if (not $name =~ /\${?VERSION}?/);
    }

    # \s makes this not work, why?
    $name = $1 if $conf_source =~ /^GETTEXT_PACKAGE=\[?([^\n\]]+)/m;
    
    # m4 macros AC_PACKAGE_NAME, AC_PACKAGE_VERSION etc. have same value
    # as corresponding $PACKAGE_NAME, $PACKAGE_VERSION etc. shell variables.
    $name =~ s/\bAC_PACKAGE_/\$PACKAGE_/g;

    $name = $domain if $domain;

    $name = SubstituteVariable ($name);
    $name =~ s/^["'](.*)["']$/$1/;

    return $name if $name;
}


sub FindPOTKeywords
{

    my $keywords = "--keyword\=\_ --keyword\=N\_ --keyword\=U\_ --keyword\=Q\_";
    my $varname = "XGETTEXT_OPTIONS";
    my $make_source; {
	local (*IN);
	open (IN, "<Makevars") || (open(IN, "<Makefile.in.in") && ($varname = "XGETTEXT_KEYWORDS")) || return $keywords;
	seek (IN, 0, 0);
	local $/; # slurp mode
	$make_source = <IN>;
	close IN;
    }

    # unwrap lines split with a trailing \
    $make_source =~  s/\\ $ \n/ /mxg;
    $keywords = $1 if $make_source =~ /^$varname[ ]*=\[?([^\n\]]+)/m;
    
    return $keywords;
}

sub FindMakevarsDomain
{

    my $domain = "";
    my $makevars_source; { 
	local (*IN);
	open (IN, "<Makevars") || return $domain;
	seek (IN, 0, 0);
	local $/; # slurp mode
	$makevars_source = <IN>;
	close IN;
    }

    $domain = $1 if $makevars_source =~ /^DOMAIN[ ]*=\[?([^\n\]\$]+)/m;
    $domain =~ s/^\s+//;
    $domain =~ s/\s+$//;
    
    return $domain;
}

sub FindMakevarsBugAddress
{

    my $address = "";
    my $makevars_source; { 
	local (*IN);
	open (IN, "<Makevars") || return undef;
	seek (IN, 0, 0);
	local $/; # slurp mode
	$makevars_source = <IN>;
	close IN;
    }

    $address = $1 if $makevars_source =~ /^MSGID_BUGS_ADDRESS[ ]*=\[?([^\n\]\$]+)/m;
    $address =~ s/^\s+//;
    $address =~ s/\s+$//;
    
    return $address;
}
